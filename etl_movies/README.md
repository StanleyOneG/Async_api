
**Переменные окружения**

Для запуска приложения необходимо в **корне проекта** создать `.env` файл и  заполнить его следующими переменными (значения по умолчанию оставить неизменными):
```

POSTGRES_PASSWORD=<пароль для PostgreSQL>
POSTGRES_USER=<имя пользователя  PostgreSQL>
POSTGRES_DB=<название базы PostgreSQL>

POSTGRES_HOST=postgresql # название Докер контейнера с базой PostgreSQL
POSTGRES_PORT=5432
POSTGRES_OPTIONS="-c search_path=content" 

ELASTIC_HOST='127.0.0.1' # Хост для Elasticsearch 
ELASTIC_PORT=9200 # Порт для Elasticsearch
ELASTIC_USERNAME=<имя пользователя для Elasticsearch>
ELASTIC_PASSWORD=<пароль для Elasticsearch>

SQLITE_PATH=/app/db.sqlite

```
**Запуск приложения**

Для запуска приложения необходимо в корневой папке проекта запустить команду `docker-compose up --build`.

**Миграция данных из SQLite в Postgres**

Миграция данных из SQLite реализована в отдельном контейнере и выполняется после проверки успешного запуска контейнера с базой PostgreSQL.


**Индексирование Elasticsearch из PostgreSQL**

ETL процесс реализован следующим образом:
1. В **Extract** модуле описан класс `ExtractorFromPostgres`, который циклически проверяет изменения в таблицах `film_work`, `person` и `genre`. Если изменения есть: 

- Возвращает id фильмов, которые нужно обновить в индексе Elasticsearch; 

- Записывает id фильмов в базу Redis для фиксации идентификаторов фильмов, которые необходимо обновить в данный момент; 

- Записывает временную отметку последней проверки PostgreSQL на предмет изменений в данных о фильмах; 

- И в методе-генераторе извлекает необходимые данные о фильмах из PostgreSQL.

2. В **Transform** модуле описан класс `Transformer`, который с помощью метода-генератора преобразует извлеченные из PostgreSQL данные о фильме в формат, подходящий для индекса Elasticsearch.

3. В **Load** модуле описан класс `ElasticLoader`, который: 

- Создает индекс "movies", если такого нет; 

- Загружает преобразованные данные о фильмах в Elasticsearch пачками по *n* фильмов.

4. Модуль **etl_process** оркестрирует ETL процесс, вызывая методы описанных классов в соответствующем порядке.

- Процесс реализован в отдельном Docker контейнере, который стартует только после проверки успешного завершения контейнера-загрузчика данных из SQLite в PostgreSQL и успешного старта контейнеров с базами PostgreSQL, Redis и Elasticsearch.